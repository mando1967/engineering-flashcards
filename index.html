<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Expires" content="0" />
  <title>Quiz Wizard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Merriweather:wght@700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css?v=105" />
  <style>
    #status {
      background: #fff3cd;
      border: 1px solid #ffeeba;
      padding: 10px;
      margin: 10px auto;
      width: 80%;
      font-family: Arial, sans-serif;
      font-size: 14px;
      border-radius: 5px;
      color: #856404;
    }
  </style>
  <!-- MathJax configuration for rendering LaTeX-style math: inline $...$ or \(...\); display $$...$$ or \[...\] -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      chtml: { matchFontHeight: true, scale: 1 }
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
  <div id="app-layout">
    <button id="sidebar-toggle" onclick="toggleSidebar()" title="Hide Sidebar">hide</button>
    
    <aside id="sidebar">
      <div class="sidebar-header">
        <span>Flashcard Sets</span>
      </div>
      <ul id="file-list"></ul>
      <div class="sidebar-footer">
        <button onclick="clearProgress()" class="clear-progress-btn" title="Clear saved progress for current quiz">Clear Progress</button>
      </div>
    </aside>

    <main id="main-content">
      <h1 id="page-title">Quiz Wizard</h1>
      <!-- Controls Panel -->
      <div id="controls-panel">
        <div class="control-group">
          <label>
            <input type="checkbox" id="randomize-checkbox" onchange="toggleRandomize()">
            Randomize Questions
          </label>
        </div>
        <div class="control-group">
          <label for="timer-select">Timer:</label>
          <select id="timer-select" onchange="updateTimer()" title="Set a timer for each individual problem (not for the entire quiz)">
            <option value="0">Off</option>
            <option value="1">1 minute</option>
            <option value="5">5 minutes</option>
            <option value="10">10 minutes</option>
            <option value="15">15 minutes</option>
            <option value="30">30 minutes</option>
          </select>
          <button id="timer-start-btn" onclick="startTimer()" style="display:none;">Start Timer</button>
          <button id="timer-stop-btn" onclick="stopTimer()" style="display:none;">Stop Timer</button>
          <span id="timer-display" style="display:none;">00:00</span>
        </div>
        <div class="control-group">
          <span id="progress-display">Question 1 of 1</span>
        </div>
        <div class="control-group">
          <span id="stats-display" title="Overall performance this session">üìä 0/0 (0%)</span>
        </div>
      </div>

      <!-- Top Navigation -->
      <div class="nav-buttons-top">
        <button id="back-btn-top" onclick="prevCard()">‚Üê Back</button>
        <select id="problem-selector" onchange="jumpToProblem()" title="Jump to problem">
          <option value="">Jump to...</option>
        </select>
        <button id="next-btn-top" onclick="nextCard()">Next ‚Üí</button>
      </div>

      <div id="flashcard-container"></div>

      <!-- Bottom Navigation -->
      <div style="text-align:center; margin-top:20px;">
        <button id="back-btn" onclick="prevCard()">‚Üê Back</button>
        <button id="show-btn" onclick="showAnswer()">Show Answer</button>
        <button id="next-btn" onclick="nextCard()" style="display:none;">Next ‚Üí</button>
      </div>
    </main>
  </div>
  
  



  <!-- ‚úÖ Move your script here -->
<script>
  let flashcards = [];
  let originalFlashcards = []; // Keep original order
  let currentIndex = 0;
  let showingAnswer = false;
  let currentQuizSet = '';
  let isRandomized = false;
  let timerInterval = null;
  let timerSeconds = 0;
  let timerDuration = 0; // in seconds
  let sidebarCollapsed = false;
  let timerWasRunning = false; // Track if timer was running
  let userSelections = {}; // Track user's answer selections
  let missedQuestions = []; // Track questions user got wrong
  let reviewQueue = []; // Queue of questions to review
  let isReviewMode = false; // Whether we're in review mode
  let originalQuestionIndex = -1; // Track original index when in review
  let performanceStats = { correct: 0, incorrect: 0, total: 0 }; // Track overall performance



  function fadeOut(element, callback) {
    element.style.opacity = 0;
    setTimeout(callback, 500);
  }

  function fadeIn(element) {
    element.style.opacity = 1;
  }

  function populateProblemSelector() {
    const selector = document.getElementById('problem-selector');
    selector.innerHTML = '<option value="">Jump to...</option>';
    
    flashcards.forEach((card, idx) => {
      // Extract problem number from title or term
      const text = card.title || card.term || '';
      const match = text.match(/^(\d+)\./);
      const problemNum = match ? match[1] : (idx + 1);
      
      const option = document.createElement('option');
      option.value = idx;
      option.textContent = `Problem ${problemNum}`;
      selector.appendChild(option);
    });
  }

  function jumpToProblem() {
    const selector = document.getElementById('problem-selector');
    const selectedIndex = parseInt(selector.value);
    
    if (!isNaN(selectedIndex) && selectedIndex >= 0 && selectedIndex < flashcards.length) {
      currentIndex = selectedIndex;
      showingAnswer = false;
      resetTimerAndAutoStart();
      renderCard();
    }
    
    // Reset selector to default
    selector.value = '';
  }

  function renderCard() {
    const container = document.getElementById('flashcard-container');
    fadeOut(container, () => {
      container.innerHTML = '';

      const card = document.createElement('div');
      card.className = 'flashcard';

      const data = flashcards[currentIndex];
      const term = data.term;
      const definition = data.definition;
      const imagePath = data.image || '';

      // If we have structured fields, render a nicer layout; otherwise fall back.
      const hasStructured = data.title || data.choices || data.answer || data.explanation || data.seeKey;

      if (hasStructured) {
        // Render choices with radio buttons
        const choicesHtml = (data.choices && data.choices.length)
          ? `<ul class="choices">${data.choices.map((c, idx) => {
              const choiceId = `choice-${currentIndex}-${idx}`;
              const isChecked = userSelections[currentIndex] === idx ? 'checked' : '';
              return `<li>
                <label>
                  <input type="radio" name="question-${currentIndex}" id="${choiceId}" value="${idx}" ${isChecked} onchange="saveUserSelection(${idx})" ${showingAnswer ? 'disabled' : ''}>
                  ${c}
                </label>
              </li>`;
            }).join('')}</ul>`
          : '';
        
        // Show user's selection in the answer and check if correct
        let userSelectionText = '';
        let isCorrect = false;
        if (showingAnswer && userSelections[currentIndex] !== undefined && data.choices) {
          const selectedIdx = userSelections[currentIndex];
          const selectedChoice = data.choices[selectedIdx];
          
          // Check if answer is correct by looking for the choice letter in the answer text
          const choiceLetter = selectedChoice.match(/^\(([a-zA-Z])\)/);
          if (choiceLetter && data.answer) {
            const correctLetter = data.answer.match(/\(([a-zA-Z])\)/);
            isCorrect = choiceLetter[1] === correctLetter?.[1];
          }
          
          const resultClass = isCorrect ? 'user-selection-correct' : 'user-selection-incorrect';
          const resultIcon = isCorrect ? '‚úì' : '‚úó';
          userSelectionText = `<div class="user-selection ${resultClass}">${resultIcon} Your answer: ${selectedChoice}</div>`;
          
          // Trigger celebration or encouragement - always show on first reveal
          if (isCorrect) {
            setTimeout(() => triggerConfetti(), 100);
          } else {
            setTimeout(() => showEncouragement(), 100);
          }
          
          // Track performance stats (only once per question)
          if (!data.hasBeenAnswered) {
            if (isCorrect) {
              performanceStats.correct++;
            } else {
              performanceStats.incorrect++;
              // Add to missed questions for review
              addToReviewQueue(currentIndex);
            }
            performanceStats.total++;
            flashcards[currentIndex].hasBeenAnswered = true;
            updateStatsDisplay();
            saveProgressToCookies();
          }
        }
        
        // Check if this problem should refer to the quiz key
        let answerHtml;
        if (data.seeKey && showingAnswer) {
          // Show simple message directing to answer key in sidebar
          answerHtml = `<div class="answer" style="display: block;">
            <span class="answer-label">Answer</span>
            ${userSelectionText}
            <div class="quiz-key-reference">
              <div class="key-icon">üîë</div>
              <div class="key-message">
                <strong>See Answer Key in sidebar for detailed solution</strong>
              </div>
            </div>
          </div>`;
        } else {
          answerHtml = data.answer
            ? `<div class="answer" style="display: ${showingAnswer ? 'block' : 'none'};"><span class="answer-label">Answer</span>${userSelectionText}<div class="answer-text">${data.answer}</div></div>`
            : `<div class="answer" style="display: ${showingAnswer ? 'block' : 'none'};"><span class="answer-label">Answer</span>${userSelectionText}<div class="answer-text">${definition || ''}</div></div>`;
        }
        
        const explanationHtml = (data.explanation && !data.seeKey)
          ? `<div class="explanation" style="display: ${showingAnswer ? 'block' : 'none'};"><span class="explanation-label">Explanation</span><div class="explanation-text">${data.explanation}</div></div>`
          : '';
        
        // Add resource links if available - always show when answer is revealed (even for seeKey problems)
        const resourcesHtml = (data.resources && data.resources.length > 0 && showingAnswer)
          ? `<div class="resources">
              <span class="resources-label">üìö Learn More:</span>
              <ul class="resource-list">
                ${data.resources.map(res => `<li><a href="${res.url}" target="_blank" rel="noopener noreferrer">${res.icon || 'üîó'} ${res.title}</a></li>`).join('')}
              </ul>
            </div>`
          : '';

        // Extract key terms from question title
        let rawText = (data.title || term).replace(/^\d+\.\s*/, '').replace(/\([a-z]\)\s*/i, '').trim();
        // Remove LaTeX, images, and extra whitespace
        rawText = rawText.replace(/\$.*?\$/g, '').replace(/\[IMAGE:.*?\]/g, '').replace(/\s+/g, ' ').trim();
        
        // Extract key physics/science concepts (common terms) - plurals and singular forms
        const keyTerms = ['capacitors?', 'resistors?', 'circuits?', 'voltage', 'current', 'charges?', 
                          'electric fields?', 'magnetic fields?', 'potential', 'energy', 'power', 
                          'forces?', 'acceleration', 'velocity', 'momentum', 'waves?', 'frequency', 
                          'resistance', 'inductance', 'batteries?', 'particles?', 'electrons?', 
                          'protons?', 'fields?', 'flux', 'capacitance', 'dielectric'];
        
        let foundTerms = [];
        const lowerText = rawText.toLowerCase();
        
        // Find all matching key terms in the question (limit to first 2-3 most relevant)
        for (let termPattern of keyTerms) {
          const regex = new RegExp('\\b(' + termPattern + ')\\b', 'i');
          const match = lowerText.match(regex);
          if (match && !foundTerms.includes(match[1])) {
            foundTerms.push(match[1]);
            if (foundTerms.length >= 3) break; // Limit to 3 terms max
          }
        }
        
        // If no key terms found, extract important-looking words (nouns, typically capitalized or technical)
        if (foundTerms.length === 0) {
          const words = rawText.split(/\s+/).filter(w => w.length > 4);
          foundTerms = words.slice(0, 2);
        }
        
        // Format the search query with quoted terms
        let searchQuery = 'Tell me more about ';
        if (foundTerms.length === 1) {
          searchQuery += `"${foundTerms[0]}"`;
        } else if (foundTerms.length === 2) {
          searchQuery += `"${foundTerms[0]}" and "${foundTerms[1]}"`;
        } else if (foundTerms.length >= 3) {
          searchQuery += foundTerms.slice(0, -1).map(t => `"${t}"`).join(', ') + ` and "${foundTerms[foundTerms.length - 1]}"`;
        } else {
          searchQuery = rawText.substring(0, 60); // Fallback
        }
        
        // Add Google AI search box - only show when answer is revealed
        const searchHtml = showingAnswer
          ? `<div class="google-search-card">
              <form onsubmit="openSearchInTab(event, this); return false;" class="google-search-form-card">
                <input type="text" name="q" value="${searchQuery.replace(/"/g, '&quot;')}" class="google-search-input-card" id="search-input-${currentIndex}" />
                <button type="submit" class="google-search-btn-card">üîç Search with AI</button>
              </form>
            </div>`
          : '';

        // Create navigation buttons for in-between placement
        const inBetweenNavHtml = showingAnswer
          ? `<div class="nav-buttons-between">
              <button onclick="prevCard()">‚Üê Back</button>
              <button onclick="nextCard()">Next ‚Üí</button>
            </div>`
          : '';
        
        // Combine explanation, resources, and search into one frame
        // For seeKey problems, still show resources and search
        const learningFrame = (explanationHtml || resourcesHtml || searchHtml) && showingAnswer
          ? `<div class="learning-frame">
              ${explanationHtml}
              ${resourcesHtml}
              ${searchHtml}
            </div>`
          : '';

        // Render all images if multiple exist
        // In Wizard Mode, paths already include quiz set directory
        const imagePrefix = currentQuizSet === 'WizardMode' ? 'tests/' : currentQuizSet + '/';
        const imagesHtml = (data.images && data.images.length > 0)
          ? data.images.map((img, idx) => 
              `<img src="${imagePrefix}${img}" alt="Diagram ${idx + 1}" onerror="this.style.display='none'" />`
            ).join('')
          : (imagePath ? `<img src="${imagePrefix}${imagePath}" alt="Diagram" onerror="this.style.display='none'" />` : '');

        card.innerHTML = `
          <div class="question-section">
            <div class="term"><span class="question-title">${data.title || term}</span></div>
            ${choicesHtml}
            ${imagesHtml}
          </div>
          ${answerHtml}
          ${inBetweenNavHtml}
          ${learningFrame}
        `;
      } else {
        // In Wizard Mode, paths already include quiz set directory
        const imgPrefix = currentQuizSet === 'WizardMode' ? 'tests/' : currentQuizSet + '/';
        card.innerHTML = `
          <div class="term"><strong>${term}</strong></div>
          <div class="definition" style="display: ${showingAnswer ? 'block' : 'none'};">${definition}</div>
          ${imagePath ? `<img src="${imgPrefix}${imagePath}" alt="Diagram" onerror="this.style.display='none'" />` : ''}
        `;
      }

      container.appendChild(card);
      // Typeset math in this card if MathJax is available
      if (window.MathJax && window.MathJax.typesetPromise) {
        window.MathJax.typesetPromise([card]).catch(err => console.error('MathJax typeset error:', err));
      }
      fadeIn(container);

      document.getElementById('show-btn').style.display = showingAnswer ? 'none' : 'inline-block';
      document.getElementById('next-btn').style.display = showingAnswer ? 'inline-block' : 'none';
      
      updateProgressDisplay();
    });
  }

  // Robust parser: groups lines until a tab-delimited line ends the question and begins the answer.
  // Additionally, extract structured fields (title, choices, answer, explanation) when possible.
  function parseFlashcards(text) {
    const lines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
    const cards = [];
    let i = 0;
    const isQuestionHeader = (s) => /^\d+\.\s/.test(s.trim());

    while (i < lines.length) {
      // Skip leading blank lines
      while (i < lines.length && !lines[i].trim()) i++;
      if (i >= lines.length) break;

      const qLines = [];
      const aLines = [];

      // Collect question lines up to the first tab-delimited line
      while (i < lines.length && !lines[i].includes('\t')) {
        // Stop if we encounter a brand-new question header while no tab seen yet (malformed block)
        if (qLines.length > 0 && isQuestionHeader(lines[i])) break;
        qLines.push(lines[i]);
        i++;
      }

      // If a tab-delimited line exists, split into question tail + answer head
      if (i < lines.length && lines[i].includes('\t')) {
        const [left, right] = lines[i].split('\t');
        qLines.push(left);
        aLines.push(right);
        i++;
        // Append explanation/answer continuation lines until next question header or next tabbed record
        while (i < lines.length && !isQuestionHeader(lines[i]) && !lines[i].includes('\t')) {
          aLines.push(lines[i]);
          i++;
        }
      }

      const term = qLines.join('\n').trim();
      const definition = aLines.join('\n').trim();

      // Try to structure the content
      let title = '';
      let choices = [];
      let answer = '';
      let explanation = '';

      // Extract image references if present (support multiple)
      let images = [];
      const imageMatches = term.matchAll(/\[IMAGE:([^\]]+)\]/g);
      for (const match of imageMatches) {
        images.push(match[1]);
      }

      // Extract title and choices from the question block
      const qNonEmpty = qLines.filter(l => l.trim().length > 0);
      if (qNonEmpty.length) {
        // Separate title lines from choice lines
        const titleLines = [];
        for (let qi = 0; qi < qNonEmpty.length; qi++) {
          const line = qNonEmpty[qi].trim();
          if (/^\([a-zA-Z]\)/.test(line)) {
            // This is a choice
            choices.push(line);
          } else {
            // This is part of the title/question
            titleLines.push(line);
          }
        }
        // Remove [IMAGE:...] tags from title and join with newlines
        title = titleLines.join('\n').replace(/\[IMAGE:[^\]]+\]/g, '').trim();
      }

      // From the answer block, separate line starting with "Answer:" and the rest as explanation
      // Also extract resource links and check for [SEE_KEY]
      let resources = [];
      let seeKey = false;
      if (aLines.length) {
        const firstNonEmptyIdx = aLines.findIndex(l => l.trim().length > 0);
        if (firstNonEmptyIdx !== -1) {
          const first = aLines[firstNonEmptyIdx];
          const m = first.match(/^\s*Answer\s*:\s*(.*)$/i);
          if (m) {
            answer = m[1].trim();
            // Check if answer contains {SEE_KEY}
            if (answer.includes('{SEE_KEY}')) {
              seeKey = true;
              answer = answer.replace(/\{SEE_KEY\}\s*/g, '').trim();
            }
            const rest = aLines.slice(firstNonEmptyIdx + 1);
            
            // Extract resources from lines starting with [RESOURCE:...]
            const nonResourceLines = [];
            rest.forEach(line => {
              const resourceMatch = line.match(/^\[RESOURCE:([^\]]+)\]\s*(.+)$/);
              if (resourceMatch) {
                const [, type, url] = resourceMatch;
                let icon = 'üîó';
                let title = url;
                
                // Parse type and set appropriate icon
                if (type.toLowerCase().includes('video')) {
                  icon = 'üé•';
                  title = 'Video: ' + (url.includes('youtube') ? 'YouTube Tutorial' : 'Video Tutorial');
                } else if (type.toLowerCase().includes('article') || type.toLowerCase().includes('text')) {
                  icon = 'üìù';
                  title = 'Article: ' + type.replace(/article|text/i, '').trim();
                } else if (type.toLowerCase().includes('khan')) {
                  icon = 'üèõÔ∏è';
                  title = 'Khan Academy: ' + type.replace(/khan/i, '').trim();
                } else {
                  title = type;
                }
                
                resources.push({ url: url.trim(), icon, title });
              } else {
                nonResourceLines.push(line);
              }
            });
            
            explanation = nonResourceLines.join('\n').trim();
          } else {
            // No explicit Answer: prefix; use full block as explanation and leave answer empty
            explanation = aLines.join('\n').trim();
          }
        }
      }

      const card = {
        term: term || '‚ö†Ô∏è Problem missing.',
        definition: definition || '‚ö†Ô∏è Answer missing.'
      };

      if (title || choices.length || answer || explanation) {
        card.title = title || term.replace(/\[IMAGE:[^\]]+\]/g, '').trim();
        if (choices.length) card.choices = choices;
        if (answer) card.answer = answer;
        if (explanation) card.explanation = explanation;
      }
      
      // Set seeKey flag regardless of structured fields
      if (seeKey) card.seeKey = true;
      
      // Store first image for backward compatibility (or all images)
      if (images.length > 0) {
        card.image = images[0]; // Use first image for now
        card.images = images; // Store all images for future use
      }
      if (resources.length > 0) card.resources = resources;

      if (term || definition) {
        cards.push(card);
      }
    }

    return cards;
  }

  async function loadWizardMode() {
    // Highlight Wizard Mode as active
    document.querySelectorAll('.accordion-item').forEach(el => el.classList.remove('active'));
    document.querySelector('.wizard-mode-item').classList.add('active');
    
    currentQuizSet = 'WizardMode';
    document.getElementById('page-title').textContent = `üßô Wizard Mode`;
    
    try {
      const quizSets = ['Quiz 2 V1', 'Quiz 2 V2', 'Quiz 2 V3', 'Quiz 2 V4', 'Quiz 2 V5'];
      const allFlashcards = [];
      
      // Load all flashcard sets
      for (const setName of quizSets) {
        const response = await fetch(`tests/${setName}/flashcards.txt?t=${Date.now()}`);
        if (!response.ok) {
          console.warn(`Failed to load ${setName}`);
          continue;
        }
        const data = await response.text();
        const cards = parseFlashcards(data);
        
        // Add source info to each card and update image paths
        cards.forEach(card => {
          card.sourceQuiz = setName;
          // Update image paths to include the quiz set directory
          if (card.image) {
            card.image = `${setName}/${card.image}`;
          }
          if (card.images) {
            card.images = card.images.map(img => `${setName}/${img}`);
          }
        });
        
        allFlashcards.push(...cards);
      }
      
      if (allFlashcards.length === 0) {
        throw new Error('No flashcards could be loaded from any quiz set.');
      }
      
      // Store the combined flashcards
      originalFlashcards = [...allFlashcards];
      
      // Auto-randomize in Wizard Mode
      flashcards = [...originalFlashcards];
      for (let i = flashcards.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [flashcards[i], flashcards[j]] = [flashcards[j], flashcards[i]];
      }
      
      currentIndex = 0;
      showingAnswer = false;
      isRandomized = true;
      document.getElementById('randomize-checkbox').checked = true;
      
      // Load saved progress for Wizard Mode
      const savedProgress = getCookie('quizwiz_WizardMode');
      
      if (savedProgress && savedProgress.performanceStats) {
        performanceStats = savedProgress.performanceStats;
        missedQuestions = savedProgress.missedQuestions || [];
        
        // Rebuild review queue from missed questions
        reviewQueue = [];
        missedQuestions.forEach(idx => {
          scheduleReview(idx);
        });
      } else {
        // Fresh start
        performanceStats = { correct: 0, incorrect: 0, total: 0 };
        missedQuestions = [];
        reviewQueue = [];
      }
      
      // Always start with clear answer selections
      userSelections = {};
      
      isReviewMode = false;
      resetTimer();
      populateProblemSelector();
      renderCard();
      updateStatsDisplay();
      
      console.log(`Wizard Mode loaded: ${allFlashcards.length} cards from ${quizSets.length} quiz sets`);
      
    } catch (err) {
      console.error('Error loading Wizard Mode:', err);
      alert(`Unable to load Wizard Mode: ${err.message}`);
    }
  }

  function loadFlashcardsFrom(path, quizSet) {
    currentQuizSet = quizSet;
    // Update page title - extract just the quiz name from the path
    const quizName = quizSet.split('/').pop();
    document.getElementById('page-title').textContent = `Quiz Wizard - ${quizName}`;
    return fetch(path)
      .then(response => {
        if (!response.ok) throw new Error(`Failed to load ${path}`);
        return response.text();
      })
      .then(data => {
        flashcards = parseFlashcards(data);
        originalFlashcards = [...flashcards];
        if (!flashcards.length) throw new Error('No flashcards parsed from file.');
        currentIndex = 0;
        showingAnswer = false;
        isRandomized = false;
        document.getElementById('randomize-checkbox').checked = false;
        
        // Load saved progress from cookies for statistics only
        const savedProgress = getCookie('quizwiz_' + currentQuizSet.replace(/[^a-zA-Z0-9]/g, '_'));
        
        if (savedProgress && savedProgress.performanceStats) {
          // Keep performance stats but clear answers to force re-answering
          performanceStats = savedProgress.performanceStats;
          missedQuestions = savedProgress.missedQuestions || [];
          
          // Rebuild review queue from missed questions
          reviewQueue = [];
          missedQuestions.forEach(idx => {
            scheduleReview(idx);
          });
        } else {
          // Fresh start
          performanceStats = { correct: 0, incorrect: 0, total: 0 };
          missedQuestions = [];
          reviewQueue = [];
        }
        
        // Always start with clear answer selections to force re-answering
        userSelections = {};
        
        isReviewMode = false;
        resetTimer();
        populateProblemSelector();
        renderCard();
        updateStatsDisplay();
      });
  }

  function addWizardMode() {
    const list = document.getElementById('file-list');
    
    // Create Wizard Mode item at the top
    const wizardItem = document.createElement('div');
    wizardItem.className = 'accordion-item wizard-mode-item';
    
    // Create header with special styling
    const header = document.createElement('div');
    header.className = 'accordion-header wizard-header';
    header.innerHTML = `
      <span class="quiz-name">üßô Wizard Mode</span>
      <span class="wizard-badge">All Sets Combined</span>
    `;
    
    // Create content
    const content = document.createElement('div');
    content.className = 'accordion-content';
    content.innerHTML = `
      <button class="load-quiz-btn wizard-load-btn" onclick="loadWizardMode()">‚ú® Start Wizard Mode</button>
      <p class="wizard-description">Combines all flashcard sets into one randomized master quiz. Track your progress across all questions and master missed cards!</p>
    `;
    
    // Toggle accordion on header click
    header.addEventListener('click', () => {
      wizardItem.classList.toggle('expanded');
    });
    
    // Assemble wizard item
    wizardItem.appendChild(header);
    wizardItem.appendChild(content);
    
    // Add to top of list
    list.insertBefore(wizardItem, list.firstChild);
  }

  function populateSidebar(quizSets) {
    const list = document.getElementById('file-list');
    list.innerHTML = '';
    quizSets.forEach((setName, idx) => {
      // Create accordion item container
      const accordionItem = document.createElement('div');
      accordionItem.className = 'accordion-item';
      
      // Create accordion header (quiz name)
      const header = document.createElement('div');
      header.className = 'accordion-header';
      header.innerHTML = `
        <span class="quiz-name">${setName}</span>
        <span class="accordion-icon">‚ñº</span>
      `;
      
      // Create accordion content (load button + PDF links)
      const content = document.createElement('div');
      content.className = 'accordion-content';
      const encodedSetName = encodeURIComponent(setName);
      
      // Quiz 2 V3 doesn't have an answer key
      const hasAnswerKey = setName !== 'Quiz 2 V3';
      // Construct the key filename properly
      const keyFileName = `${setName} KEY.pdf`;
      const encodedKeyFileName = encodeURIComponent(keyFileName);
      const answerKeyLink = hasAnswerKey 
        ? `<a href="tests/${encodedSetName}/${encodedKeyFileName}" target="_blank" class="pdf-link">üîë Answer Key</a>`
        : `<span class="pdf-link disabled">üîë Answer Key (Not Available)</span>`;
      
      content.innerHTML = `
        <button class="load-quiz-btn" data-quiz="${setName}">üìö Load Flashcards</button>
        <a href="tests/${encodedSetName}/${encodedSetName}.pdf" target="_blank" class="pdf-link">üìÑ Quiz PDF</a>
        ${answerKeyLink}
      `;
      
      // Toggle accordion on header click (just expand/collapse, don't load)
      header.addEventListener('click', () => {
        accordionItem.classList.toggle('expanded');
      });
      
      // Load quiz on button click
      const loadBtn = content.querySelector('.load-quiz-btn');
      loadBtn.addEventListener('click', () => {
        // Highlight active quiz
        document.querySelectorAll('.accordion-item').forEach(el => el.classList.remove('active'));
        accordionItem.classList.add('active');
        
        loadFlashcardsFrom(`tests/${setName}/flashcards.txt?t=${Date.now()}`, `tests/${setName}`).catch(err => {
          console.error(err);
          alert(`Unable to load ${setName}: ${err.message}`);
        });
      });
      
      // Assemble accordion item
      accordionItem.appendChild(header);
      accordionItem.appendChild(content);
      list.appendChild(accordionItem);
      
      // Auto-load and expand first quiz
      if (idx === 0) {
        accordionItem.classList.add('active', 'expanded');
        loadFlashcardsFrom(`tests/${setName}/flashcards.txt?t=${Date.now()}`, `tests/${setName}`).catch(err => console.error(err));
      }
    });
  }

  function initSidebar() {
    // Hardcode available quiz sets for now
    const quizSets = ['Quiz 2 V1', 'Quiz 2 V2', 'Quiz 2 V3', 'Quiz 2 V4', 'Quiz 2 V5'];
    populateSidebar(quizSets);
    addWizardMode();
    
    // Auto-close sidebar on mobile/tablet
    if (window.innerWidth <= 768) {
      const sidebar = document.getElementById('sidebar');
      const toggle = document.getElementById('sidebar-toggle');
      sidebar.style.display = 'none';
      toggle.textContent = 'show';
      toggle.title = 'Show Sidebar';
      toggle.classList.add('collapsed');
      sidebarCollapsed = true;
    }
  }

  // Initialize sidebar on load
  initSidebar();

  function showAnswer() {
    showingAnswer = true;
    renderCard();
  }

  function saveUserSelection(choiceIdx) {
    userSelections[currentIndex] = choiceIdx;
    saveProgressToCookies();
  }

  function addToReviewQueue(questionIdx) {
    // Don't add if already in review queue
    if (!reviewQueue.includes(questionIdx) && !missedQuestions.includes(questionIdx)) {
      missedQuestions.push(questionIdx);
      // Add to review queue - will be interleaved later
      scheduleReview(questionIdx);
      saveProgressToCookies();
    }
  }

  function scheduleReview(questionIdx) {
    // Add the question to appear again after 2-3 more questions
    const insertPosition = Math.min(currentIndex + 2 + Math.floor(Math.random() * 2), flashcards.length - 1);
    if (!reviewQueue.some(item => item.index === questionIdx)) {
      reviewQueue.push({ index: questionIdx, scheduledAfter: insertPosition });
    }
  }

  function getNextQuestionIndex() {
    // Check if we should show a review question
    const dueReviews = reviewQueue.filter(item => item.scheduledAfter <= currentIndex);
    
    if (dueReviews.length > 0) {
      // Show a review question
      const reviewItem = dueReviews[0];
      reviewQueue = reviewQueue.filter(item => item !== reviewItem);
      isReviewMode = true;
      originalQuestionIndex = currentIndex;
      return reviewItem.index;
    }
    
    isReviewMode = false;
    return (currentIndex + 1) % flashcards.length;
  }

  function nextCard() {
    if (isReviewMode) {
      // Return from review mode
      currentIndex = originalQuestionIndex + 1;
      isReviewMode = false;
    } else {
      currentIndex = getNextQuestionIndex();
    }
    showingAnswer = false;
    resetTimerAndAutoStart();
    renderCard();
  }

  function prevCard() {
    currentIndex = (currentIndex - 1 + flashcards.length) % flashcards.length;
    showingAnswer = false;
    resetTimerAndAutoStart();
    renderCard();
  }

  function toggleSidebar() {
    sidebarCollapsed = !sidebarCollapsed;
    const sidebar = document.getElementById('sidebar');
    const toggle = document.getElementById('sidebar-toggle');
    
    if (sidebarCollapsed) {
      sidebar.style.display = 'none';
      toggle.textContent = 'show';
      toggle.title = 'Show Sidebar';
      toggle.classList.add('collapsed');
    } else {
      sidebar.style.display = 'block';
      toggle.textContent = 'hide';
      toggle.title = 'Hide Sidebar';
      toggle.classList.remove('collapsed');
    }
  }

  function toggleRandomize() {
    isRandomized = document.getElementById('randomize-checkbox').checked;
    
    if (isRandomized) {
      // Shuffle the flashcards
      flashcards = [...originalFlashcards];
      for (let i = flashcards.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [flashcards[i], flashcards[j]] = [flashcards[j], flashcards[i]];
      }
    } else {
      // Restore original order
      flashcards = [...originalFlashcards];
    }
    
    currentIndex = 0;
    showingAnswer = false;
    userSelections = {}; // Clear selections when randomizing
    resetTimer();
    renderCard();
  }

  function updateTimer() {
    const select = document.getElementById('timer-select');
    const minutes = parseInt(select.value);
    timerDuration = minutes * 60;
    
    const startBtn = document.getElementById('timer-start-btn');
    const stopBtn = document.getElementById('timer-stop-btn');
    const display = document.getElementById('timer-display');
    
    if (minutes > 0) {
      startBtn.style.display = 'inline-block';
      display.style.display = 'inline-block';
      stopTimer();
      timerSeconds = timerDuration;
      updateTimerDisplay();
    } else {
      startBtn.style.display = 'none';
      stopBtn.style.display = 'none';
      display.style.display = 'none';
      stopTimer();
    }
  }

  function startTimer() {
    if (timerInterval) return; // Already running
    
    const startBtn = document.getElementById('timer-start-btn');
    const stopBtn = document.getElementById('timer-stop-btn');
    
    startBtn.style.display = 'none';
    stopBtn.style.display = 'inline-block';
    timerWasRunning = true;
    
    timerInterval = setInterval(() => {
      timerSeconds--;
      updateTimerDisplay();
      
      if (timerSeconds <= 0) {
        stopTimer();
        alert('Time is up!');
      }
    }, 1000);
  }

  function stopTimer() {
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
    
    const startBtn = document.getElementById('timer-start-btn');
    const stopBtn = document.getElementById('timer-stop-btn');
    
    if (timerDuration > 0) {
      startBtn.style.display = 'inline-block';
      stopBtn.style.display = 'none';
    }
    timerWasRunning = false;
  }

  function resetTimer() {
    stopTimer();
    timerSeconds = timerDuration;
    updateTimerDisplay();
  }

  function resetTimerAndAutoStart() {
    const wasRunning = timerWasRunning;
    stopTimer();
    timerSeconds = timerDuration;
    updateTimerDisplay();
    
    // Auto-start if timer was running before
    if (wasRunning && timerDuration > 0) {
      startTimer();
    }
  }

  function updateTimerDisplay() {
    const display = document.getElementById('timer-display');
    const minutes = Math.floor(timerSeconds / 60);
    const seconds = timerSeconds % 60;
    display.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    
    // Change color when time is running low
    if (timerSeconds <= 60 && timerSeconds > 0) {
      display.style.color = '#d32f2f';
      display.style.fontWeight = 'bold';
    } else {
      display.style.color = '#2c3e50';
      display.style.fontWeight = 'normal';
    }
  }

  function updateProgressDisplay() {
    const display = document.getElementById('progress-display');
    const reviewText = isReviewMode ? ' (Review)' : '';
    
    // In Wizard Mode, show source quiz and problem number
    if (currentQuizSet === 'WizardMode' && flashcards[currentIndex]) {
      const card = flashcards[currentIndex];
      const sourceQuiz = card.sourceQuiz || 'Unknown';
      
      // Extract problem number from title
      const problemMatch = (card.title || card.term || '').match(/^(\d+)\./);  
      const problemNum = problemMatch ? problemMatch[1] : '?';
      
      display.textContent = `${sourceQuiz} - #${problemNum} | ${currentIndex + 1} of ${flashcards.length}${reviewText}`;
    } else {
      display.textContent = `Question ${currentIndex + 1} of ${flashcards.length}${reviewText}`;
    }
  }

  function updateStatsDisplay() {
    const display = document.getElementById('stats-display');
    const percentage = performanceStats.total > 0 
      ? Math.round((performanceStats.correct / performanceStats.total) * 100) 
      : 0;
    display.textContent = `üìä ${performanceStats.correct}/${performanceStats.total} (${percentage}%)`;
    
    // Color code based on performance
    if (percentage >= 80) {
      display.style.color = '#28a745';
      display.style.fontWeight = 'bold';
    } else if (percentage >= 60) {
      display.style.color = '#ffc107';
      display.style.fontWeight = 'bold';
    } else if (performanceStats.total > 0) {
      display.style.color = '#dc3545';
      display.style.fontWeight = 'bold';
    } else {
      display.style.color = '#2c3e50';
      display.style.fontWeight = 'normal';
    }
  }

  function triggerConfetti() {
    // Create confetti container
    const container = document.createElement('div');
    container.className = 'confetti-container';
    document.body.appendChild(container);
    
    // Create multiple confetti pieces
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#6c5ce7', '#a29bfe', '#fd79a8'];
    const confettiCount = 50;
    
    for (let i = 0; i < confettiCount; i++) {
      const confetti = document.createElement('div');
      confetti.className = 'confetti';
      confetti.style.left = Math.random() * 100 + '%';
      confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.animationDelay = Math.random() * 0.3 + 's';
      confetti.style.animationDuration = (Math.random() * 1 + 1.5) + 's';
      container.appendChild(confetti);
    }
    
    // Remove after animation
    setTimeout(() => {
      container.remove();
    }, 3000);
  }

  function showEncouragement() {
    const messages = [
      "Keep going! Learning from mistakes makes you stronger! üí™",
      "Don't worry! Every expert was once a beginner! üåü",
      "Great effort! You'll get it next time! üéØ",
      "Nice try! Practice makes perfect! üìö",
      "You're doing great! Keep learning! üöÄ",
      "Almost there! You've got this! ‚≠ê",
      "Excellent effort! Review and try again! üí°",
      "Stay positive! Mistakes are part of learning! üåà"
    ];
    
    const message = messages[Math.floor(Math.random() * messages.length)];
    
    // Create encouragement popup
    const popup = document.createElement('div');
    popup.className = 'encouragement-popup';
    popup.textContent = message;
    document.body.appendChild(popup);
    
    // Animate in
    setTimeout(() => popup.classList.add('show'), 10);
    
    // Remove after delay
    setTimeout(() => {
      popup.classList.remove('show');
      setTimeout(() => popup.remove(), 300);
    }, 3000);
  }

  // Open search in new tab
  function openSearchInTab(event, form) {
    event.preventDefault();
    
    const searchQuery = form.querySelector('input[name="q"]').value;
    const searchUrl = 'https://www.google.com/search?q=' + encodeURIComponent(searchQuery);
    
    // Open in new tab (browser security restrictions prevent reliable tab reuse)
    window.open(searchUrl, '_blank');
  }

  // Cookie management functions
  function setCookie(name, value, days = 30) {
    const date = new Date();
    date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
    const expires = "expires=" + date.toUTCString();
    document.cookie = name + "=" + encodeURIComponent(JSON.stringify(value)) + ";" + expires + ";path=/";
  }

  function getCookie(name) {
    const nameEQ = name + "=";
    const ca = document.cookie.split(';');
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) === ' ') c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) {
        try {
          return JSON.parse(decodeURIComponent(c.substring(nameEQ.length, c.length)));
        } catch (e) {
          return null;
        }
      }
    }
    return null;
  }

  function saveProgressToCookies() {
    if (!currentQuizSet) return;
    
    const progressData = {
      userSelections: userSelections,
      missedQuestions: missedQuestions,
      performanceStats: performanceStats,
      timestamp: new Date().toISOString()
    };
    
    setCookie('quizwiz_' + currentQuizSet.replace(/[^a-zA-Z0-9]/g, '_'), progressData);
  }

  function loadProgressFromCookies() {
    // This function is now only used for reference
    // Progress loading is handled in loadFlashcardsFrom() to control what gets restored
    if (!currentQuizSet) return;
    
    const progressData = getCookie('quizwiz_' + currentQuizSet.replace(/[^a-zA-Z0-9]/g, '_'));
    
    if (progressData) {
      // Only restore stats and missed questions, not user selections
      missedQuestions = progressData.missedQuestions || [];
      performanceStats = progressData.performanceStats || { correct: 0, incorrect: 0, total: 0 };
      
      // Rebuild review queue from missed questions
      reviewQueue = [];
      missedQuestions.forEach(idx => {
        scheduleReview(idx);
      });
      
      updateStatsDisplay();
      console.log('Progress loaded from cookies (stats only):', progressData.timestamp);
    }
  }

  function clearProgress() {
    if (!currentQuizSet) return;
    
    if (confirm('Clear your answer selections? Your performance statistics and missed questions tracking will be preserved.')) {
      // Only clear answer selections, keep performance stats and missed questions
      userSelections = {};
      
      // Save updated progress (keeping performanceStats and missedQuestions)
      saveProgressToCookies();
      
      // Re-render current card without showing previous answer
      showingAnswer = false;
      renderCard();
      
      alert('Answer selections cleared! Your performance statistics are preserved.');
    }
  }
</script>



</body>
</html>





