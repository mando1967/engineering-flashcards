<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Expires" content="0" />
  <title>Quiz Wizard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Merriweather:wght@700&family=MedievalSharp&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css?v=107" />
  <style>
    #status {
      background: #fff3cd;
      border: 1px solid #ffeeba;
      padding: 10px;
      margin: 10px auto;
      width: 80%;
      font-family: Arial, sans-serif;
      font-size: 14px;
      border-radius: 5px;
      color: #856404;
    }
  </style>
  <!-- MathJax configuration for rendering LaTeX-style math: inline $...$ or \(...\); display $$...$$ or \[...\] -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      chtml: { matchFontHeight: true, scale: 1 }
    };
  </script>
  <!-- Marked.js for Markdown parsing - load before MathJax -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script>
    // Configure marked to not escape HTML and to preserve LaTeX
    if (typeof marked !== 'undefined') {
      marked.setOptions({
        breaks: true,
        gfm: true
      });
    }
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
  <div id="app-layout">
    <button id="sidebar-toggle" onclick="toggleSidebar()">üßô hide</button>
    
    <aside id="sidebar">
      <div class="sidebar-header">
        <div class="subject-selector">
          <label for="subject-select">Subject:</label>
          <select id="subject-select" onchange="selectSubject(this.value)"></select>
        </div>
        <button id="mode-toggle" class="mode-toggle-btn tooltip-trigger" data-tooltip="Switch between Quiz mode (testing) and Tutor mode (learning)" onclick="toggleMode()">
          <span id="mode-icon">üìù</span>
        </button>
      </div>
      <div class="sidebar-content">
        <ul id="file-list"></ul>
      </div>
    </aside>

    <main id="main-content">
      <div class="title-bar">
        <h1 id="page-title">Quiz Wizard</h1>
        <button onclick="clearProgress()" class="clear-progress-btn tooltip-trigger" data-tooltip="Clear your progress, statistics, and answers for the current quiz.
Your flashcard history will be reset.">üßô Clear Progress</button>
      </div>
      <!-- Controls Panel -->
      <div id="controls-panel">
        <div class="control-group">
          <label>
            <input type="checkbox" id="randomize-checkbox" onchange="toggleRandomize()">
            Randomize Questions
          </label>
        </div>
        <div class="control-group">
          <label for="timer-select">Timer:</label>
          <span class="tooltip-trigger" data-tooltip="Timer applies to each problem (not for the entire quiz)">
            <select id="timer-select" onchange="updateTimer()">
              <option value="0">Off</option>
              <option value="1">1 minute</option>
              <option value="2">2 minutes</option>
              <option value="3">3 minutes</option>
              <option value="4">4 minutes</option>
              <option value="5">5 minutes</option>
              <option value="6">6 minutes</option>
              <option value="7">7 minutes</option>
              <option value="8">8 minutes</option>
              <option value="9">9 minutes</option>
              <option value="10">10 minutes</option>
            </select>
          </span>
          <button id="timer-start-btn" onclick="startTimer()" style="display:none;">Start Timer</button>
          <button id="timer-stop-btn" onclick="stopTimer()" style="display:none;">Stop Timer</button>
          <span id="timer-display" style="display:none;">00:00</span>
        </div>
        <div class="control-group">
          <span id="progress-display">Question 1 of 1</span>
        </div>
        <div class="control-group">
          <span id="stats-display" class="tooltip-trigger" data-tooltip="Overall performance this session">üìä 0/0 (0%)</span>
        </div>
      </div>

      <!-- Top Navigation -->
      <div class="nav-buttons-top">
        <button id="back-btn-top" onclick="prevCard()">‚Üê Back</button>
        <span class="tooltip-trigger" data-tooltip="Jump to any problem in the quiz">
          <select id="problem-selector" onchange="jumpToProblem()">
            <option value="">Jump to...</option>
          </select>
        </span>
        <button id="next-btn-top" onclick="nextCard()">Next ‚Üí</button>
      </div>

      <div id="flashcard-container"></div>

      <!-- Bottom Navigation -->
      <div style="text-align:center; margin-top:20px;">
        <button id="back-btn" onclick="prevCard()">‚Üê Back</button>
        <button id="show-btn" onclick="showAnswer()">Show Answer</button>
        <button id="next-btn" onclick="nextCard()" style="display:none;">Next ‚Üí</button>
      </div>
    </main>
  </div>
  
  



  <!-- ‚úÖ Move your script here -->
<script>
  let flashcards = [];
  let originalFlashcards = []; // Keep original order
  let currentIndex = 0;
  let showingAnswer = false;
  let currentQuizSet = '';
  let isRandomized = false;
  let timerInterval = null;
  let timerSeconds = 0;
  let timerDuration = 0; // in seconds
  let sidebarCollapsed = false;
  let timerWasRunning = false; // Track if timer was running
  let userSelections = {}; // Track user's answer selections
  let missedQuestions = []; // Track questions user got wrong
  let reviewQueue = []; // Queue of questions to review
  let isReviewMode = false; // Whether we're in review mode
  let originalQuestionIndex = -1; // Track original index when in review
  let performanceStats = { correct: 0, incorrect: 0, total: 0 }; // Track overall performance



  function fadeOut(element, callback) {
    element.style.opacity = 0;
    setTimeout(callback, 500);
  }

  function fadeIn(element) {
    element.style.opacity = 1;
  }

  function populateProblemSelector() {
    const selector = document.getElementById('problem-selector');
    selector.innerHTML = '<option value="">Jump to...</option>';
    
    flashcards.forEach((card, idx) => {
      // Extract problem number from title or term
      const text = card.title || card.term || '';
      const match = text.match(/^(\d+)\./);
      const problemNum = match ? match[1] : (idx + 1);
      
      const option = document.createElement('option');
      option.value = idx;
      
      // Include source quiz version if available
      if (card.sourceQuiz) {
        option.textContent = `Problem ${problemNum} (${card.sourceQuiz})`;
      } else {
        option.textContent = `Problem ${problemNum}`;
      }
      
      selector.appendChild(option);
    });
  }

  function jumpToProblem() {
    const selector = document.getElementById('problem-selector');
    const selectedIndex = parseInt(selector.value);
    
    if (!isNaN(selectedIndex) && selectedIndex >= 0 && selectedIndex < flashcards.length) {
      currentIndex = selectedIndex;
      showingAnswer = false;
      resetTimerAndAutoStart();
      saveProgressToCookies();
      renderCard();
    }
    
    // Reset selector to default
    selector.value = '';
  }

  function renderCard() {
    const container = document.getElementById('flashcard-container');
    fadeOut(container, () => {
      container.innerHTML = '';

      const card = document.createElement('div');
      card.className = 'flashcard';

      const data = flashcards[currentIndex];
      
      console.log('üí° Data at render time - currentIndex:', currentIndex, {
        hasExplanation: !!data.explanation,
        hasAnswer: !!data.answer,
        hasTitle: !!data.title,
        explanationLength: data.explanation ? data.explanation.length : 0,
        termPreview: data.term?.substring(0, 40)
      });
      
      const term = data.term;
      const definition = data.definition;
      const imagePath = data.image || '';

      // If we have structured fields, render a nicer layout; otherwise fall back.
      const hasStructured = data.title || data.choices || data.answer || data.explanation || data.seeKey;

      // Check if this is a tutorial (has explanation but no answer/choices)
      const isTutorial = data.explanation && !data.answer && !data.choices;
      
      console.log('üéØ RENDERING - isTutorial:', isTutorial, 'hasExplanation:', !!data.explanation, 'hasAnswer:', !!data.answer);

      if (isTutorial) {
        console.log('‚úÖ Using TUTORIAL rendering');
        console.log('Explanation content:', data.explanation?.substring(0, 200));

        // Tutorial mode: Show concept and examples together (no "Show Answer" needed)
        card.innerHTML = `
          <div class="question-section">
            <div class="term"><span class="question-title">${data.title || term}</span></div>
          </div>
          <div class="answer" style="display: block;">
            <span class="answer-label">Explanation & Examples</span>
            <div class="answer-text">${typeof marked !== 'undefined' && marked.parse && data.explanation ? marked.parse(data.explanation) : (data.explanation || '')}</div>
          </div>
        `;
        
        console.log('Tutorial card HTML created');
      } else if (hasStructured) {
        // Render choices with radio buttons
        const choicesHtml = (data.choices && data.choices.length)
          ? `<ul class="choices">${data.choices.map((c, idx) => {
              const choiceId = `choice-${currentIndex}-${idx}`;
              const isChecked = userSelections[currentIndex] === idx ? 'checked' : '';
              return `<li>
                <label>
                  <input type="radio" name="question-${currentIndex}" id="${choiceId}" value="${idx}" ${isChecked} onchange="saveUserSelection(${idx})" ${showingAnswer ? 'disabled' : ''}>
                  ${c}
                </label>
              </li>`;
            }).join('')}</ul>`
          : '';
        
        // Show user's selection in the answer and check if correct
        let userSelectionText = '';
        let isCorrect = false;
        if (showingAnswer && userSelections[currentIndex] !== undefined && data.choices && data.choices.length > 0) {
          const selectedIdx = userSelections[currentIndex];
          const selectedChoice = data.choices[selectedIdx];
          
          // Check if answer is correct by looking for the choice letter in the answer text
          if (selectedChoice) {
            const choiceLetter = selectedChoice.match(/^\(([a-zA-Z])\)/);
            if (choiceLetter && data.answer) {
              const correctLetter = data.answer.match(/\(([a-zA-Z])\)/);
              isCorrect = choiceLetter[1] === correctLetter?.[1];
            }
          }
          
          const resultClass = isCorrect ? 'user-selection-correct' : 'user-selection-incorrect';
          const resultIcon = isCorrect ? '‚úì' : '‚úó';
          userSelectionText = `<div class="user-selection ${resultClass}">${resultIcon} Your answer: ${selectedChoice}</div>`;
          
          // Trigger celebration or encouragement - always show on first reveal
          if (isCorrect) {
            setTimeout(() => triggerConfetti(), 100);
          } else {
            setTimeout(() => showEncouragement(), 100);
          }
          
          // Track performance stats (only once per question)
          if (!data.hasBeenAnswered) {
            if (isCorrect) {
              performanceStats.correct++;
            } else {
              performanceStats.incorrect++;
              // Add to missed questions for review
              addToReviewQueue(currentIndex);
            }
            performanceStats.total++;
            flashcards[currentIndex].hasBeenAnswered = true;
            updateStatsDisplay();
            saveProgressToCookies();
          }
        }
        
        // Check if this problem should refer to the quiz key
        let answerHtml;
        if (data.seeKey && showingAnswer) {
          // Show simple message directing to answer key in sidebar
          answerHtml = `<div class="answer" style="display: block;">
            <span class="answer-label">Answer</span>
            ${userSelectionText}
            <div class="quiz-key-reference">
              <div class="key-icon">üîë</div>
              <div class="key-message">
                <strong>See Answer Key in sidebar for detailed solution</strong>
              </div>
            </div>
          </div>`;
        } else {
          // For tutorial cards (no answer, only explanation with examples), show the full content
          const contentToShow = data.answer ? data.answer : (data.explanation ? data.explanation : definition);
          const parsedContent = (data.explanation && !data.answer && typeof marked !== 'undefined' && marked.parse && contentToShow) ? marked.parse(contentToShow) : (contentToShow || '');
          answerHtml = `<div class="answer" style="display: ${showingAnswer ? 'block' : 'none'};"><span class="answer-label">${data.answer ? 'Answer' : 'Explanation & Examples'}</span>${userSelectionText}<div class="answer-text">${parsedContent}</div></div>`;
        }
        
        // Only show explanation separately if there's also an answer (quiz mode)
        // For tutorials (no answer), explanation is already shown in the answer section
        const explanationHtml = (data.explanation && data.answer && !data.seeKey)
          ? `<div class="explanation" style="display: ${showingAnswer ? 'block' : 'none'};"><span class="explanation-label">Explanation</span><div class="explanation-text">${typeof marked !== 'undefined' && marked.parse && data.explanation ? marked.parse(data.explanation) : (data.explanation || '')}</div></div>`
          : '';
        
        // Add resource links if available - always show when answer is revealed (even for seeKey problems)
        const resourcesHtml = (data.resources && data.resources.length > 0 && showingAnswer)
          ? `<div class="resources">
              <span class="resources-label">üìö Learn More:</span>
              <ul class="resource-list">
                ${data.resources.map(res => `<li><a href="${res.url}" target="_blank" rel="noopener noreferrer">${res.icon || 'üîó'} ${res.title}</a></li>`).join('')}
              </ul>
            </div>`
          : '';

        // Extract key terms from question title
        let rawText = (data.title || term).replace(/^\d+\.\s*/, '').replace(/\([a-z]\)\s*/i, '').trim();
        // Remove LaTeX, images, and extra whitespace
        rawText = rawText.replace(/\$.*?\$/g, '').replace(/\[IMAGE:.*?\]/g, '').replace(/\s+/g, ' ').trim();
        
        // Extract key physics/science concepts (common terms) - plurals and singular forms
        const keyTerms = ['capacitors?', 'resistors?', 'circuits?', 'voltage', 'current', 'charges?', 
                          'electric fields?', 'magnetic fields?', 'potential', 'energy', 'power', 
                          'forces?', 'acceleration', 'velocity', 'momentum', 'waves?', 'frequency', 
                          'resistance', 'inductance', 'batteries?', 'particles?', 'electrons?', 
                          'protons?', 'fields?', 'flux', 'capacitance', 'dielectric'];
        
        let foundTerms = [];
        const lowerText = rawText.toLowerCase();
        
        // Find all matching key terms in the question (limit to first 2-3 most relevant)
        for (let termPattern of keyTerms) {
          const regex = new RegExp('\\b(' + termPattern + ')\\b', 'i');
          const match = lowerText.match(regex);
          if (match && !foundTerms.includes(match[1])) {
            foundTerms.push(match[1]);
            if (foundTerms.length >= 3) break; // Limit to 3 terms max
          }
        }
        
        // If no key terms found, extract important-looking words (nouns, typically capitalized or technical)
        if (foundTerms.length === 0) {
          const words = rawText.split(/\s+/).filter(w => w.length > 4);
          foundTerms = words.slice(0, 2);
        }
        
        // Format the search query with quoted terms
        let searchQuery = 'Tell me more about ';
        if (foundTerms.length === 1) {
          searchQuery += `"${foundTerms[0]}"`;
        } else if (foundTerms.length === 2) {
          searchQuery += `"${foundTerms[0]}" and "${foundTerms[1]}"`;
        } else if (foundTerms.length >= 3) {
          searchQuery += foundTerms.slice(0, -1).map(t => `"${t}"`).join(', ') + ` and "${foundTerms[foundTerms.length - 1]}"`;
        } else {
          searchQuery = rawText.substring(0, 60); // Fallback
        }
        
        // Add Google AI search box - only show when answer is revealed
        const searchHtml = showingAnswer
          ? `<div class="google-search-card">
              <form onsubmit="openSearchInTab(event, this); return false;" class="google-search-form-card">
                <input type="text" name="q" value="${searchQuery.replace(/"/g, '&quot;')}" class="google-search-input-card" id="search-input-${currentIndex}" />
                <button type="submit" class="google-search-btn-card">üîç Search with AI</button>
              </form>
            </div>`
          : '';

        // Create navigation buttons for in-between placement
        const inBetweenNavHtml = showingAnswer
          ? `<div class="nav-buttons-between">
              <button onclick="prevCard()">‚Üê Back</button>
              <button onclick="nextCard()">Next ‚Üí</button>
            </div>`
          : '';
        
        // Combine explanation, resources, and search into one frame
        // For seeKey problems, still show resources and search
        const learningFrame = (explanationHtml || resourcesHtml || searchHtml) && showingAnswer
          ? `<div class="learning-frame">
              ${explanationHtml}
              ${resourcesHtml}
              ${searchHtml}
            </div>`
          : '';

        // Render all images if multiple exist
        // In Wizard Mode, paths already include quiz set directory
        // Image paths are already full paths (updated in loadFlashcardsFrom)
        const imagesHtml = (data.images && data.images.length > 0)
          ? data.images.map((img, idx) => 
              `<img src="${img}" alt="Diagram ${idx + 1}" onerror="this.style.display='none'" />`
            ).join('')
          : (imagePath ? `<img src="${imagePath}" alt="Diagram" onerror="this.style.display='none'" />` : '');

        card.innerHTML = `
          <div class="question-section">
            <div class="term"><span class="question-title">${data.title || term}</span></div>
            ${choicesHtml}
            ${imagesHtml}
          </div>
          ${answerHtml}
          ${inBetweenNavHtml}
          ${learningFrame}
        `;
      } else {
        // Image paths are already full paths (updated in loadFlashcardsFrom)
        card.innerHTML = `
          <div class="term"><strong>${term}</strong></div>
          <div class="definition" style="display: ${showingAnswer ? 'block' : 'none'};">${definition}</div>
          ${imagePath ? `<img src="${imagePath}" alt="Diagram" onerror="this.style.display='none'" />` : ''}
        `;
      }

      container.appendChild(card);
      // Typeset math in this card if MathJax is available
      if (window.MathJax && window.MathJax.typesetPromise) {
        window.MathJax.typesetPromise([card]).catch(err => console.error('MathJax typeset error:', err));
      }
      fadeIn(container);

      // For tutorials, hide "Show Answer" button since content is always visible
      if (isTutorial) {
        document.getElementById('show-btn').style.display = 'none';
        document.getElementById('next-btn').style.display = 'inline-block';
      } else {
        document.getElementById('show-btn').style.display = showingAnswer ? 'none' : 'inline-block';
        document.getElementById('next-btn').style.display = showingAnswer ? 'inline-block' : 'none';
      }
      
      updateProgressDisplay();
    });
  }

  // Robust parser: groups lines until a tab-delimited line ends the question and begins the answer.
  // Additionally, extract structured fields (title, choices, answer, explanation) when possible.
  function parseFlashcards(text) {
    const lines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
    const cards = [];
    let i = 0;
    // Match both "1. " format and "Concept 1:" format
    const isQuestionHeader = (s) => /^(\d+\.|Concept\s+\d+:)/.test(s.trim());

    while (i < lines.length) {
      // Skip leading blank lines
      while (i < lines.length && !lines[i].trim()) i++;
      if (i >= lines.length) break;

      const qLines = [];
      const aLines = [];

      // Collect question lines up to the first tab-delimited line
      while (i < lines.length && !lines[i].includes('\t')) {
        // Stop if we encounter a brand-new question header while no tab seen yet (malformed block)
        if (qLines.length > 0 && isQuestionHeader(lines[i])) break;
        qLines.push(lines[i]);
        i++;
      }

      // If a tab-delimited line exists, split into question tail + answer head
      if (i < lines.length && lines[i].includes('\t')) {
        const [left, right] = lines[i].split('\t');
        qLines.push(left);
        aLines.push(right);
        i++;
        // Append explanation/answer continuation lines until next question header or next tabbed record
        while (i < lines.length && !isQuestionHeader(lines[i]) && !lines[i].includes('\t')) {
          aLines.push(lines[i]);
          i++;
        }
      }

      const term = qLines.join('\n').trim();
      const definition = aLines.join('\n').trim();
      
      console.log('=== Parsed Card ===');
      console.log('Term:', term.substring(0, 80));
      console.log('Definition:', definition.substring(0, 150));
      console.log('qLines:', qLines.length, 'aLines:', aLines.length);
      console.log('Full definition length:', definition.length);

      // Try to structure the content
      let title = '';
      let choices = [];
      let answer = '';
      let explanation = '';

      // Extract image references if present (support multiple)
      let images = [];
      const imageMatches = term.matchAll(/\[IMAGE:([^\]]+)\]/g);
      for (const match of imageMatches) {
        images.push(match[1]);
      }

      // Extract title and choices from the question block
      const qNonEmpty = qLines.filter(l => l.trim().length > 0);
      if (qNonEmpty.length) {
        // Separate title lines from choice lines
        const titleLines = [];
        for (let qi = 0; qi < qNonEmpty.length; qi++) {
          const line = qNonEmpty[qi].trim();
          if (/^\([a-zA-Z]\)/.test(line)) {
            // This is a choice
            choices.push(line);
          } else {
            // This is part of the title/question
            titleLines.push(line);
          }
        }
        // Remove [IMAGE:...] tags from title and join with newlines
        title = titleLines.join('\n').replace(/\[IMAGE:[^\]]+\]/g, '').trim();
      }

      // From the answer block, separate line starting with "Answer:" and the rest as explanation
      // Also extract resource links and check for [SEE_KEY]
      let resources = [];
      let seeKey = false;
      if (aLines.length) {
        const firstNonEmptyIdx = aLines.findIndex(l => l.trim().length > 0);
        if (firstNonEmptyIdx !== -1) {
          const first = aLines[firstNonEmptyIdx];
          const m = first.match(/^\s*Answer\s*:\s*(.*)$/i);
          if (m) {
            answer = m[1].trim();
            // Check if answer contains {SEE_KEY}
            if (answer.includes('{SEE_KEY}')) {
              seeKey = true;
              answer = answer.replace(/\{SEE_KEY\}\s*/g, '').trim();
            }
            const rest = aLines.slice(firstNonEmptyIdx + 1);
            
            // Extract resources from lines starting with [RESOURCE:...]
            const nonResourceLines = [];
            rest.forEach(line => {
              const resourceMatch = line.match(/^\[RESOURCE:([^\]]+)\]\s*(.+)$/);
              if (resourceMatch) {
                const [, type, url] = resourceMatch;
                let icon = 'üîó';
                let title = url;
                
                // Parse type and set appropriate icon
                if (type.toLowerCase().includes('video')) {
                  icon = 'üé•';
                  title = 'Video: ' + (url.includes('youtube') ? 'YouTube Tutorial' : 'Video Tutorial');
                } else if (type.toLowerCase().includes('article') || type.toLowerCase().includes('text')) {
                  icon = 'üìù';
                  title = 'Article: ' + type.replace(/article|text/i, '').trim();
                } else if (type.toLowerCase().includes('khan')) {
                  icon = 'üèõÔ∏è';
                  title = 'Khan Academy: ' + type.replace(/khan/i, '').trim();
                } else {
                  title = type;
                }
                
                resources.push({ url: url.trim(), icon, title });
              } else {
                nonResourceLines.push(line);
              }
            });
            
            explanation = nonResourceLines.join('\n').trim();
          } else {
            // No explicit Answer: prefix; use full block as explanation and leave answer empty
            explanation = aLines.join('\n').trim();
          }
        }
      }

      const card = {
        term: term || '‚ö†Ô∏è Problem missing.',
        definition: definition || '‚ö†Ô∏è Answer missing.'
      };

      if (title || choices.length || answer || explanation) {
        card.title = title || term.replace(/\[IMAGE:[^\]]+\]/g, '').trim();
        if (choices.length) card.choices = choices;
        if (answer) card.answer = answer;
        if (explanation) card.explanation = explanation;
      }
      
      console.log('Card created:', {
        hasTitleField: !!card.title,
        hasAnswerField: !!card.answer,
        hasExplanationField: !!card.explanation,
        explanationVar: explanation ? explanation.substring(0, 50) : 'empty'
      });
      
      // Set seeKey flag regardless of structured fields
      if (seeKey) card.seeKey = true;
      
      // Store first image for backward compatibility (or all images)
      if (images.length > 0) {
        card.image = images[0]; // Use first image for now
        card.images = images; // Store all images for future use
      }
      if (resources.length > 0) card.resources = resources;

      if (term || definition) {
        cards.push(card);
      }
    }

    return cards;
  }

  async function loadWizardMode(testSet) {
    currentQuizSet = `${testSet.id}/wizard`;
    const modePrefix = currentMode === 'quiz' ? 'üßô Wizard Mode' : 'üßô Tutor Wizard Mode';
    document.getElementById('page-title').textContent = `${modePrefix} - ${testSet.name}`;
    
    try {
      const allFlashcards = [];
      const basePath = getModePath(testSet);
      
      // Load all quiz versions for this test set
      for (const quiz of testSet.quizVersions) {
        const path = `${basePath}/${quiz.name}/flashcards.txt?t=${Date.now()}`;
        const response = await fetch(path);
        if (!response.ok) {
          console.warn(`Failed to load ${quiz.name}`);
          continue;
        }
        const data = await response.text();
        const cards = parseFlashcards(data);
        
        // Add source info to each card and update image paths
        cards.forEach(card => {
          card.sourceQuiz = quiz.name;
          // Update image paths to include the full path (relative to mode directory)
          const imagePath = `${testSet.tutorPath || testSet.quizPath || testSet.path}/${quiz.name}`;
          if (card.image) {
            card.image = `${imagePath}/${card.image}`;
          }
          if (card.images) {
            card.images = card.images.map(img => `${imagePath}/${img}`);
          }
        });
        
        allFlashcards.push(...cards);
      }
      
      if (allFlashcards.length === 0) {
        throw new Error('No flashcards could be loaded from any quiz version');
      }
      
      // Store the combined flashcards
      originalFlashcards = [...allFlashcards];
      
      // Auto-randomize in Wizard Mode
      flashcards = [...originalFlashcards];
      for (let i = flashcards.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [flashcards[i], flashcards[j]] = [flashcards[j], flashcards[i]];
      }
      
      currentIndex = 0;
      showingAnswer = false;
      isRandomized = true;
      document.getElementById('randomize-checkbox').checked = true;
      
      // Load saved progress
      const savedProgress = getCookie('quizwiz_' + currentQuizSet.replace(/[^a-zA-Z0-9]/g, '_'));
      
      if (savedProgress && savedProgress.performanceStats) {
        performanceStats = savedProgress.performanceStats;
        missedQuestions = savedProgress.missedQuestions || [];
        
        reviewQueue = [];
        missedQuestions.forEach(idx => {
          scheduleReview(idx);
        });
      } else {
        performanceStats = { correct: 0, incorrect: 0, total: 0 };
        missedQuestions = [];
        reviewQueue = [];
      }
      
      userSelections = {};
      isReviewMode = false;
      resetTimer();
      populateProblemSelector();
      renderCard();
      updateStatsDisplay();
      
      // Highlight wizard mode in sidebar
      document.querySelectorAll('.accordion-item').forEach(el => el.classList.remove('active'));
      
      console.log(`Wizard Mode loaded: ${allFlashcards.length} cards from ${testSet.quizVersions.length} quiz versions`);
      
    } catch (err) {
      console.error('Error loading Wizard Mode:', err);
      alert(`Unable to load Wizard Mode: ${err.message}`);
    }
  }

  function parseTutorialJson(jsonData) {
    const tutorial = JSON.parse(jsonData);
    const cards = [];
    
    // Add introduction card
    if (tutorial.introduction) {
      const conceptsList = tutorial.introduction.concepts.map((c, i) => `${i + 1}. ${c}`).join('\n');
      cards.push({
        term: tutorial.introduction.title,
        definition: tutorial.introduction.description,
        title: tutorial.introduction.title,
        explanation: `${tutorial.introduction.description}\n\nConcepts Covered:\n${conceptsList}`
      });
    }
    
    // Add concept cards
    tutorial.concepts.forEach((concept, idx) => {
      cards.push({
        term: `${idx + 1}. ${concept.title}`,
        definition: concept.explanation,
        title: `${idx + 1}. ${concept.title}`,
        explanation: `${concept.explanation}\n\nExample:\n${concept.examples}`
      });
    });
    
    return cards;
  }

  function parseQuizJson(jsonData) {
    const quiz = JSON.parse(jsonData);
    const cards = [];
    
    quiz.questions.forEach(q => {
      // Build the question text with choices
      const questionLines = [`${q.number}. ${q.points ? `(${q.points} points) ` : ''}${q.question}`];
      q.choices.forEach(choice => questionLines.push(choice));
      
      const card = {
        term: questionLines.join('\n'),
        definition: q.explanation || '',
        title: questionLines[0],
        choices: q.choices,
        answer: q.answer,
        explanation: q.explanation
      };
      
      // Add images if present
      if (q.images && q.images.length > 0) {
        card.images = q.images;
        card.image = q.images[0]; // First image for backward compatibility
      }
      
      // Add resources if present
      if (q.resources && q.resources.length > 0) {
        card.resources = q.resources.map(r => ({
          url: r.url,
          title: r.type,
          icon: r.type.toLowerCase().includes('video') ? 'üé•' : 
                r.type.toLowerCase().includes('khan') ? 'üèõÔ∏è' : 
                r.type.toLowerCase().includes('article') ? 'üìù' : 'üîó'
        }));
      }
      
      // Add seeKey flag if present
      if (q.seeKey) {
        card.seeKey = true;
      }
      
      cards.push(card);
    });
    
    return cards;
  }

  function loadFlashcardsFrom(path, quizSet, isJsonTutorial = false, isJsonQuiz = false) {
    currentQuizSet = quizSet;
    // Update page title - extract just the quiz name from the path
    const quizName = quizSet.split('/').pop();
    const modeTitle = currentMode === 'quiz' ? 'Quiz Wizard' : 'Tutor Wizard';
    document.getElementById('page-title').textContent = `${modeTitle} - ${quizName}`;
    
    // For JSON files, replace flashcards.txt with appropriate JSON filename
    if (isJsonTutorial) {
      path = path.replace('flashcards.txt', 'tutorial.json');
    } else if (isJsonQuiz) {
      path = path.replace('flashcards.txt', 'quiz.json');
    }
    
    // URL encode the path to handle spaces and special characters
    // Split by '?' to preserve query string, then encode only the path part
    const [pathPart, queryPart] = path.split('?');
    const encodedPath = pathPart.split('/').map(segment => encodeURIComponent(segment)).join('/') + 
                        (queryPart ? '?' + queryPart : '');
    
    // Extract the directory path from the full path (e.g., "tests/Physics/PHYS 214 - Test 1/Quiz 2 V3")
    const dirPath = pathPart.substring(0, pathPart.lastIndexOf('/'));
    
    return fetch(encodedPath)
      .then(response => {
        if (!response.ok) throw new Error(`Failed to load ${path}`);
        return response.text();
      })
      .then(data => {
        flashcards = isJsonTutorial ? parseTutorialJson(data) : 
                     isJsonQuiz ? parseQuizJson(data) : 
                     parseFlashcards(data);
        
        console.log('üìö Flashcards after parsing - Total:', flashcards.length);
        flashcards.forEach((card, idx) => {
          console.log(`  Card ${idx}: hasExplanation=${!!card.explanation}, title="${card.title?.substring(0, 30)}"`);
        });
        
        // Force fresh start for tutorials - clear any saved progress
        if (currentMode === 'tutor') {
          console.log('üßπ Clearing saved progress for tutorial');
          currentIndex = 0;
        }
        
        // Update image paths to include the full directory path
        flashcards.forEach((card, idx) => {
          if (card.image) {
            card.image = `${dirPath}/${card.image}`;
          }
          if (card.images) {
            card.images = card.images.map(img => `${dirPath}/${img}`);
          }
        });
        
        originalFlashcards = [...flashcards];
        if (!flashcards.length) throw new Error('No flashcards parsed from file.');
        
        showingAnswer = false;
        isRandomized = false;
        document.getElementById('randomize-checkbox').checked = false;
        
        // Load saved progress from cookies including current position
        const savedProgress = getCookie('quizwiz_' + currentQuizSet.replace(/[^a-zA-Z0-9]/g, '_'));
        
        if (savedProgress) {
          // Restore all saved progress including position
          performanceStats = savedProgress.performanceStats || { correct: 0, incorrect: 0, total: 0 };
          missedQuestions = savedProgress.missedQuestions || [];
          userSelections = savedProgress.userSelections || {};
          currentIndex = savedProgress.currentIndex || 0;
          
          // Ensure currentIndex is valid for this quiz
          if (currentIndex >= flashcards.length) {
            currentIndex = 0;
          }
          
          // Rebuild review queue from missed questions
          reviewQueue = [];
          missedQuestions.forEach(idx => {
            scheduleReview(idx);
          });
        } else {
          // Fresh start
          performanceStats = { correct: 0, incorrect: 0, total: 0 };
          missedQuestions = [];
          reviewQueue = [];
          userSelections = {};
          currentIndex = 0;
        }
        
        isReviewMode = false;
        resetTimer();
        populateProblemSelector();
        
        console.log('üîç Right before renderCard - flashcards[0]:', {
          hasExplanation: !!flashcards[0]?.explanation,
          hasAnswer: !!flashcards[0]?.answer,
          hasTitle: !!flashcards[0]?.title
        });
        
        renderCard();
        updateStatsDisplay();
      });
  }

  let appConfig = null;
  let currentSubject = null;
  let currentMode = 'quiz'; // 'quiz' or 'tutor'

  async function loadConfig() {
    try {
      const response = await fetch(`config.json?t=${Date.now()}`);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      appConfig = await response.json();
      return appConfig;
    } catch (error) {
      console.error('Failed to load config:', error);
      alert('ERROR: Failed to load config.json - ' + error.message);
      return null;
    }
  }

  function createSubjectTabs(subjects) {
    const selectElement = document.getElementById('subject-select');
    selectElement.innerHTML = '';
    
    console.log('createSubjectTabs called with mode:', currentMode);
    
    // Filter subjects based on current mode
    const filteredSubjects = subjects.filter(subject => {
      if (currentMode === 'tutor') {
        return !subject.quizOnly; // Hide quizOnly subjects in tutor mode
      } else {
        return !subject.tutorOnly; // Hide tutorOnly subjects in quiz mode
      }
    });
    
    console.log('Creating dropdown for subjects:', filteredSubjects.map(s => s.name));
    
    filteredSubjects.forEach((subject, idx) => {
      const option = document.createElement('option');
      option.value = subject.id;
      option.textContent = subject.name;
      
      if (idx === 0) {
        option.selected = true;
        currentSubject = subject.id;
      }
      
      selectElement.appendChild(option);
    });
  }

  function selectSubject(subjectId) {
    currentSubject = subjectId;
    
    // Update dropdown selection
    const selectElement = document.getElementById('subject-select');
    if (selectElement) {
      selectElement.value = subjectId;
    }
    
    // Find subject config
    const subject = appConfig.subjects.find(s => s.id === subjectId);
    if (subject) {
      populateSidebar(subject.testSets, true);
    }
  }

  function toggleMode() {
    // Toggle between quiz and tutor modes
    currentMode = currentMode === 'quiz' ? 'tutor' : 'quiz';
    
    console.log('Switched to mode:', currentMode);
    
    // Update icon
    const modeIcon = document.getElementById('mode-icon');
    modeIcon.textContent = currentMode === 'quiz' ? 'üìù' : 'üë®‚Äçüè´';
    
    // Update page title
    const pageTitle = document.getElementById('page-title');
    pageTitle.textContent = currentMode === 'quiz' ? 'Quiz Wizard' : 'Tutor Wizard';
    
    // Update timer tooltip
    const timerTooltip = document.querySelector('#timer-select').parentElement;
    if (currentMode === 'tutor') {
      timerTooltip.setAttribute('data-tooltip', 'Timer for study session (time allotted for learning)');
    } else {
      timerTooltip.setAttribute('data-tooltip', 'Timer applies to each problem (not for the entire quiz)');
    }
    
    // Save mode preference
    setCookie('quizwiz_mode', currentMode, 365);
    
    // Clear flashcard display
    const flashcardContainer = document.getElementById('flashcard-container');
    flashcardContainer.innerHTML = '';
    
    // Recreate subject tabs to show/hide mode-specific subjects
    if (appConfig) {
      createSubjectTabs(appConfig.subjects);
      
      // Select first available subject in the new mode and load its content
      const filteredSubjects = appConfig.subjects.filter(subject => {
        if (currentMode === 'tutor') {
          return !subject.quizOnly; // Hide quizOnly subjects in tutor mode
        } else {
          return !subject.tutorOnly; // Hide tutorOnly subjects in quiz mode
        }
      });
      
      console.log('Filtered subjects for', currentMode, 'mode:', filteredSubjects.map(s => s.name));
      
      if (filteredSubjects.length > 0) {
        currentSubject = filteredSubjects[0].id;
        
        // Manually trigger the active state on the first tab
        const firstTab = document.querySelector('.subject-tab');
        if (firstTab) {
          firstTab.classList.add('active');
        }
        
        // Load the sidebar with the first subject's test sets
        populateSidebar(filteredSubjects[0].testSets, true);
      }
    }
  }

  function getModePath(testSet) {
    // Return the appropriate path based on current mode
    if (currentMode === 'tutor') {
      return `tutor/${testSet.tutorPath || testSet.quizPath || testSet.path}`;
    } else {
      return `tests/${testSet.quizPath || testSet.path}`;
    }
  }

  function populateSidebar(testSets, autoLoad = false) {
    const list = document.getElementById('file-list');
    list.innerHTML = '';
    
    testSets.forEach((testSet, idx) => {
      const accordionItem = document.createElement('li');
      accordionItem.className = 'accordion-item';
      
      const header = document.createElement('div');
      header.className = 'accordion-header';
      header.innerHTML = `
        <span class="quiz-name">${testSet.name}</span>
        <span class="accordion-icon">‚ñº</span>
      `;
      
      const content = document.createElement('div');
      content.className = 'accordion-content';
      
      // Add quiz versions as nested accordions
      testSet.quizVersions.forEach((quiz, qIdx) => {
        // Create nested accordion item for each quiz
        const quizAccordion = document.createElement('div');
        quizAccordion.className = 'accordion-item quiz-accordion';
        
        // Quiz header (clickable to expand)
        const quizHeader = document.createElement('div');
        quizHeader.className = 'accordion-header';
        quizHeader.innerHTML = `
          <span class="quiz-name">${quiz.name}</span>
          <span class="accordion-icon">‚ñº</span>
        `;
        
        // Quiz content (buttons and links)
        const quizContent = document.createElement('div');
        quizContent.className = 'accordion-content';
        
        const encodedQuizName = encodeURIComponent(quiz.name);
        const basePath = getModePath(testSet);
        
        // Check if answer key exists (Quiz 2 V3 doesn't have one)
        const hasAnswerKey = quiz.name !== 'Quiz 2 V3';
        const keyFileName = `${quiz.name} KEY.pdf`;
        const encodedKeyFileName = encodeURIComponent(keyFileName);
        
        // Only show PDFs in quiz mode
        if (currentMode === 'quiz') {
          const answerKeyLink = hasAnswerKey 
            ? `<a href="${basePath}/${encodedQuizName}/${encodedKeyFileName}" target="_blank" class="pdf-link">üîë Answer Key</a>`
            : `<span class="pdf-link disabled">üîë Answer Key (Not Available)</span>`;
          
          quizContent.innerHTML = `
            <a href="${basePath}/${encodedQuizName}/${encodedQuizName}.pdf" target="_blank" class="pdf-link">üìÑ Quiz PDF</a>
            ${answerKeyLink}
          `;
        } else {
          quizContent.innerHTML = '';
        }
        
        // Toggle quiz accordion and load flashcards
        quizHeader.addEventListener('click', (e) => {
          e.stopPropagation(); // Prevent parent accordion from toggling
          
          const isCurrentlyExpanded = quizAccordion.classList.contains('expanded');
          
          // Close all other quiz accordions in this test set
          content.querySelectorAll('.quiz-accordion').forEach(qa => {
            qa.classList.remove('expanded');
            qa.classList.remove('active');
          });
          
          // Remove active from all accordions
          document.querySelectorAll('.accordion-item').forEach(el => el.classList.remove('active'));
          accordionItem.classList.add('active');
          
          // If this one wasn't expanded, expand it and load flashcards
          if (!isCurrentlyExpanded) {
            quizAccordion.classList.add('expanded');
            quizAccordion.classList.add('active');
            
            // Load flashcards
            const path = `${basePath}/${quiz.name}/flashcards.txt?t=${Date.now()}`;
            const quizSetId = `${testSet.id}/${quiz.id}`;
            loadFlashcardsFrom(path, quizSetId, testSet.isTutorialJson, quiz.isQuizJson).catch(err => {
              console.error(err);
              alert(`Unable to load ${quiz.name}: ${err.message}`);
            });
          }
        });
        
        quizAccordion.appendChild(quizHeader);
        quizAccordion.appendChild(quizContent);
        content.appendChild(quizAccordion);
        
        // Auto-load first quiz of first test set (but don't expand)
        if (autoLoad && idx === 0 && qIdx === 0) {
          quizAccordion.classList.add('active');
          const basePath = getModePath(testSet);
          const path = `${basePath}/${quiz.name}/flashcards.txt?t=${Date.now()}`;
          const quizSetId = `${testSet.id}/${quiz.id}`;
          loadFlashcardsFrom(path, quizSetId, testSet.isTutorialJson, quiz.isQuizJson).catch(err => console.error(err));
        }
      });
      
      // Add Wizard Mode button at the end (after all quiz versions) - only if tutorPath exists
      if (testSet.tutorPath) {
        const wizardBtn = document.createElement('button');
        wizardBtn.className = 'load-quiz-btn wizard-mode-btn';
        wizardBtn.innerHTML = 'üßô <div style="line-height: 1.3;">Wizard Mode<br><span style="font-size: 0.85em;">(combined quizzes)</span></div>';
        wizardBtn.onclick = () => loadWizardMode(testSet);
        content.appendChild(wizardBtn);
      }
      
      // Toggle accordion
      header.addEventListener('click', (e) => {
        accordionItem.classList.toggle('expanded');
      });
      
      accordionItem.appendChild(header);
      accordionItem.appendChild(content);
      list.appendChild(accordionItem);
      
      // Auto-expand first test set
      if (idx === 0) {
        accordionItem.classList.add('active', 'expanded');
      }
    });
  }

  async function initSidebar() {
    const config = await loadConfig();
    if (!config || !config.subjects || config.subjects.length === 0) {
      console.error('Invalid or empty config');
      alert('ERROR: Config is invalid or empty');
      return;
    }
    
    // Restore saved mode preference (default to quiz mode)
    const savedMode = getCookie('quizwiz_mode');
    if (savedMode === 'quiz' || savedMode === 'tutor') {
      currentMode = savedMode;
    } else {
      currentMode = 'quiz'; // Default to quiz mode
      setCookie('quizwiz_mode', 'quiz', 365); // Save default
    }
    
    console.log('Current mode on init:', currentMode);
    
    // Update UI to match current mode
    const modeIcon = document.getElementById('mode-icon');
    modeIcon.textContent = currentMode === 'quiz' ? 'üìù' : 'üë®‚Äçüè´';
    
    const pageTitle = document.getElementById('page-title');
    pageTitle.textContent = currentMode === 'quiz' ? 'Quiz Wizard' : 'Tutor Wizard';
    
    // Update timer tooltip based on mode
    const timerTooltip = document.querySelector('#timer-select').parentElement;
    if (currentMode === 'tutor') {
      timerTooltip.setAttribute('data-tooltip', 'Timer for study session (time allotted for learning)');
    } else {
      timerTooltip.setAttribute('data-tooltip', 'Timer applies to each problem (not for the entire quiz)');
    }
    
    // Create subject tabs (will be filtered by mode)
    createSubjectTabs(config.subjects);
    
    // Get filtered subjects based on current mode
    const filteredSubjects = config.subjects.filter(subject => {
      if (currentMode === 'tutor') {
        return !subject.quizOnly; // Hide quizOnly subjects in tutor mode
      } else {
        return !subject.tutorOnly; // Hide tutorOnly subjects in quiz mode
      }
    });
    
    console.log('Available subjects on init:', filteredSubjects.map(s => s.name));
    
    // Load first available subject's test sets
    if (filteredSubjects.length > 0) {
      const firstSubject = filteredSubjects[0];
      currentSubject = firstSubject.id;
      populateSidebar(firstSubject.testSets, true);
    }
    
    // Auto-close sidebar on mobile/tablet
    if (window.innerWidth <= 768) {
      const sidebar = document.getElementById('sidebar');
      const toggle = document.getElementById('sidebar-toggle');
      sidebar.style.display = 'none';
      toggle.textContent = 'üßô show';
      toggle.classList.add('collapsed');
      sidebarCollapsed = true;
    }
  }

  // Initialize sidebar on load
  initSidebar();

  function showAnswer() {
    showingAnswer = true;
    renderCard();
  }

  function saveUserSelection(choiceIdx) {
    userSelections[currentIndex] = choiceIdx;
    saveProgressToCookies();
  }

  function addToReviewQueue(questionIdx) {
    // Don't add if already in review queue
    if (!reviewQueue.includes(questionIdx) && !missedQuestions.includes(questionIdx)) {
      missedQuestions.push(questionIdx);
      // Add to review queue - will be interleaved later
      scheduleReview(questionIdx);
      saveProgressToCookies();
    }
  }

  function scheduleReview(questionIdx) {
    // Add the question to appear again after 2-3 more questions
    const insertPosition = Math.min(currentIndex + 2 + Math.floor(Math.random() * 2), flashcards.length - 1);
    if (!reviewQueue.some(item => item.index === questionIdx)) {
      reviewQueue.push({ index: questionIdx, scheduledAfter: insertPosition });
    }
  }

  function getNextQuestionIndex() {
    // Check if we should show a review question
    const dueReviews = reviewQueue.filter(item => item.scheduledAfter <= currentIndex);
    
    if (dueReviews.length > 0) {
      // Show a review question
      const reviewItem = dueReviews[0];
      reviewQueue = reviewQueue.filter(item => item !== reviewItem);
      isReviewMode = true;
      originalQuestionIndex = currentIndex;
      return reviewItem.index;
    }
    
    isReviewMode = false;
    return (currentIndex + 1) % flashcards.length;
  }

  function nextCard() {
    if (isReviewMode) {
      // Return from review mode
      currentIndex = originalQuestionIndex + 1;
      isReviewMode = false;
    } else {
      currentIndex = (currentIndex + 1) % flashcards.length;
    }
    showingAnswer = false;
    resetTimerAndAutoStart();
    saveProgressToCookies();
    renderCard();
  }

  function prevCard() {
    currentIndex = (currentIndex - 1 + flashcards.length) % flashcards.length;
    showingAnswer = false;
    resetTimerAndAutoStart();
    saveProgressToCookies();
    renderCard();
  }

  function toggleSidebar() {
    sidebarCollapsed = !sidebarCollapsed;
    const sidebar = document.getElementById('sidebar');
    const toggle = document.getElementById('sidebar-toggle');
    
    if (sidebarCollapsed) {
      sidebar.style.display = 'none';
      toggle.textContent = 'üßô show';
      toggle.classList.add('collapsed');
    } else {
      sidebar.style.display = 'block';
      toggle.textContent = 'üßô hide';
      toggle.classList.remove('collapsed');
    }
  }

  function toggleRandomize() {
    isRandomized = document.getElementById('randomize-checkbox').checked;
    
    if (isRandomized) {
      // Shuffle the flashcards
      flashcards = [...originalFlashcards];
      for (let i = flashcards.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [flashcards[i], flashcards[j]] = [flashcards[j], flashcards[i]];
      }
    } else {
      // Restore original order
      flashcards = [...originalFlashcards];
    }
    
    currentIndex = 0;
    showingAnswer = false;
    userSelections = {}; // Clear selections when randomizing
    resetTimer();
    renderCard();
  }

  function updateTimer() {
    const select = document.getElementById('timer-select');
    const minutes = parseInt(select.value);
    timerDuration = minutes * 60;
    
    const startBtn = document.getElementById('timer-start-btn');
    const stopBtn = document.getElementById('timer-stop-btn');
    const display = document.getElementById('timer-display');
    
    if (minutes > 0) {
      startBtn.style.display = 'inline-block';
      display.style.display = 'inline-block';
      stopTimer();
      timerSeconds = timerDuration;
      updateTimerDisplay();
    } else {
      startBtn.style.display = 'none';
      stopBtn.style.display = 'none';
      display.style.display = 'none';
      stopTimer();
    }
  }

  function startTimer() {
    if (timerInterval) return; // Already running
    
    const startBtn = document.getElementById('timer-start-btn');
    const stopBtn = document.getElementById('timer-stop-btn');
    
    startBtn.style.display = 'none';
    stopBtn.style.display = 'inline-block';
    timerWasRunning = true;
    
    timerInterval = setInterval(() => {
      timerSeconds--;
      updateTimerDisplay();
      
      if (timerSeconds <= 0) {
        stopTimer();
        alert('Time is up!');
      }
    }, 1000);
  }

  function stopTimer() {
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
    
    const startBtn = document.getElementById('timer-start-btn');
    const stopBtn = document.getElementById('timer-stop-btn');
    
    if (timerDuration > 0) {
      startBtn.style.display = 'inline-block';
      stopBtn.style.display = 'none';
    }
    timerWasRunning = false;
  }

  function resetTimer() {
    stopTimer();
    timerSeconds = timerDuration;
    updateTimerDisplay();
  }

  function resetTimerAndAutoStart() {
    const wasRunning = timerWasRunning;
    stopTimer();
    timerSeconds = timerDuration;
    updateTimerDisplay();
    
    // Auto-start if timer was running before
    if (wasRunning && timerDuration > 0) {
      startTimer();
    }
  }

  function updateTimerDisplay() {
    const display = document.getElementById('timer-display');
    const minutes = Math.floor(timerSeconds / 60);
    const seconds = timerSeconds % 60;
    display.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    
    // Change color when time is running low
    if (timerSeconds <= 60 && timerSeconds > 0) {
      display.style.color = '#d32f2f';
      display.style.fontWeight = 'bold';
    } else {
      display.style.color = '#2c3e50';
      display.style.fontWeight = 'normal';
    }
  }

  function updateProgressDisplay() {
    const display = document.getElementById('progress-display');
    const reviewText = isReviewMode ? ' (Review)' : '';
    
    // In Wizard Mode, show source quiz and problem number
    if (currentQuizSet === 'WizardMode' && flashcards[currentIndex]) {
      const card = flashcards[currentIndex];
      const sourceQuiz = card.sourceQuiz || 'Unknown';
      
      // Extract problem number from title
      const problemMatch = (card.title || card.term || '').match(/^(\d+)\./);  
      const problemNum = problemMatch ? problemMatch[1] : '?';
      
      display.textContent = `${sourceQuiz} - #${problemNum} | ${currentIndex + 1} of ${flashcards.length}${reviewText}`;
    } else {
      display.textContent = `Question ${currentIndex + 1} of ${flashcards.length}${reviewText}`;
    }
  }

  function updateStatsDisplay() {
    const display = document.getElementById('stats-display');
    const percentage = performanceStats.total > 0 
      ? Math.round((performanceStats.correct / performanceStats.total) * 100) 
      : 0;
    display.textContent = `üìä ${performanceStats.correct}/${performanceStats.total} (${percentage}%)`;
    
    // Color code based on performance
    if (percentage >= 80) {
      display.style.color = '#28a745';
      display.style.fontWeight = 'bold';
    } else if (percentage >= 60) {
      display.style.color = '#ffc107';
      display.style.fontWeight = 'bold';
    } else if (performanceStats.total > 0) {
      display.style.color = '#dc3545';
      display.style.fontWeight = 'bold';
    } else {
      display.style.color = '#2c3e50';
      display.style.fontWeight = 'normal';
    }
  }

  function triggerConfetti() {
    // Create confetti container
    const container = document.createElement('div');
    container.className = 'confetti-container';
    document.body.appendChild(container);
    
    // Create multiple confetti pieces
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#6c5ce7', '#a29bfe', '#fd79a8'];
    const confettiCount = 50;
    
    for (let i = 0; i < confettiCount; i++) {
      const confetti = document.createElement('div');
      confetti.className = 'confetti';
      confetti.style.left = Math.random() * 100 + '%';
      confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.animationDelay = Math.random() * 0.3 + 's';
      confetti.style.animationDuration = (Math.random() * 1 + 1.5) + 's';
      container.appendChild(confetti);
    }
    
    // Remove after animation
    setTimeout(() => {
      container.remove();
    }, 3000);
  }

  function showEncouragement() {
    const messages = [
      "Keep going! Learning from mistakes makes you stronger! üí™",
      "Don't worry! Every expert was once a beginner! üåü",
      "Great effort! You'll get it next time! üéØ",
      "Nice try! Practice makes perfect! üìö",
      "You're doing great! Keep learning! üöÄ",
      "Almost there! You've got this! ‚≠ê",
      "Excellent effort! Review and try again! üí°",
      "Stay positive! Mistakes are part of learning! üåà"
    ];
    
    const message = messages[Math.floor(Math.random() * messages.length)];
    
    // Create encouragement popup
    const popup = document.createElement('div');
    popup.className = 'encouragement-popup';
    popup.textContent = message;
    document.body.appendChild(popup);
    
    // Animate in
    setTimeout(() => popup.classList.add('show'), 10);
    
    // Remove after delay
    setTimeout(() => {
      popup.classList.remove('show');
      setTimeout(() => popup.remove(), 300);
    }, 3000);
  }

  // Open search in new tab
  function openSearchInTab(event, form) {
    event.preventDefault();
    
    const searchQuery = form.querySelector('input[name="q"]').value;
    const searchUrl = 'https://www.google.com/search?q=' + encodeURIComponent(searchQuery);
    
    // Open in new tab (browser security restrictions prevent reliable tab reuse)
    window.open(searchUrl, '_blank');
  }

  // Cookie management functions
  function setCookie(name, value, days = 30) {
    const date = new Date();
    date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
    const expires = "expires=" + date.toUTCString();
    document.cookie = name + "=" + encodeURIComponent(JSON.stringify(value)) + ";" + expires + ";path=/";
  }

  function getCookie(name) {
    const nameEQ = name + "=";
    const ca = document.cookie.split(';');
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) === ' ') c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) {
        try {
          return JSON.parse(decodeURIComponent(c.substring(nameEQ.length, c.length)));
        } catch (e) {
          return null;
        }
      }
    }
    return null;
  }

  function saveProgressToCookies() {
    if (!currentQuizSet) return;
    
    const progressData = {
      userSelections: userSelections,
      missedQuestions: missedQuestions,
      performanceStats: performanceStats,
      currentIndex: currentIndex,
      timestamp: new Date().toISOString()
    };
    
    setCookie('quizwiz_' + currentQuizSet.replace(/[^a-zA-Z0-9]/g, '_'), progressData);
  }

  function loadProgressFromCookies() {
    // This function is now only used for reference
    // Progress loading is handled in loadFlashcardsFrom() to control what gets restored
    if (!currentQuizSet) return;
    
    const progressData = getCookie('quizwiz_' + currentQuizSet.replace(/[^a-zA-Z0-9]/g, '_'));
    
    if (progressData) {
      // Only restore stats and missed questions, not user selections
      missedQuestions = progressData.missedQuestions || [];
      performanceStats = progressData.performanceStats || { correct: 0, incorrect: 0, total: 0 };
      
      // Rebuild review queue from missed questions
      reviewQueue = [];
      missedQuestions.forEach(idx => {
        scheduleReview(idx);
      });
      
      updateStatsDisplay();
      console.log('Progress loaded from cookies (stats only):', progressData.timestamp);
    }
  }

  function clearProgress() {
    if (!currentQuizSet) return;
    
    if (confirm('Clear your answer selections? Your performance statistics and missed questions tracking will be preserved.')) {
      // Only clear answer selections, keep performance stats and missed questions
      userSelections = {};
      
      // Save updated progress (keeping performanceStats and missedQuestions)
      saveProgressToCookies();
      
      // Re-render current card without showing previous answer
      showingAnswer = false;
      renderCard();
      
      alert('Answer selections cleared! Your performance statistics are preserved.');
    }
  }
</script>



</body>
</html>





